<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SUDOKU: SUFFERING</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --bg: #000000;
            --blood: #ff0000;
            --dark-blood: #4a0000;
            --terminal: #a0a0a0;
        }

        body {
            background-color: var(--bg);
            color: var(--terminal);
            font-family: 'VT323', monospace;
            margin: 0; height: 100vh; overflow: hidden;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-transform: uppercase;
        }

        /* --- CRT EFFECT & SCANLINES --- */
        body::before {
            content: " "; display: block; position: absolute; top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 998; background-size: 100% 2px, 3px 100%; pointer-events: none;
        }
        .scanline {
            width: 100%; height: 100px; z-index: 999; background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(255, 0, 0, 0.1) 50%, rgba(0,0,0,0) 100%);
            opacity: 0.1; position: absolute; bottom: 100%; animation: scanline 10s linear infinite; pointer-events: none;
        }
        @keyframes scanline { 0% { bottom: 100%; } 100% { bottom: -100%; } }

        /* --- GLITCH TEXT --- */
        .glitch { position: relative; color: var(--blood); font-size: 2rem; animation: glitch-skew 1s infinite linear alternate-reverse; }
        .glitch::before, .glitch::after {
            content: attr(data-text); position: absolute; left: 0; width: 100%; height: 100%;
        }
        .glitch::before { left: 2px; text-shadow: -2px 0 #ff00c1; clip: rect(44px, 450px, 56px, 0); animation: glitch-anim 5s infinite linear alternate-reverse; }
        .glitch::after { left: -2px; text-shadow: -2px 0 #00fff9; clip: rect(44px, 450px, 56px, 0); animation: glitch-anim2 1s infinite linear alternate-reverse; }
        @keyframes glitch-skew { 0% { transform: skew(0deg); } 10% { transform: skew(5deg); } 20% { transform: skew(-5deg); } 100% { transform: skew(0deg); } }

        /* --- START BUTTON --- */
        #start-overlay {
            position: fixed; inset: 0; background: #000; z-index: 5000;
            display: flex; align-items: center; justify-content: center; flex-direction: column;
        }
        .btn-blood {
            background: #000; border: 2px solid var(--blood); color: var(--blood);
            font-family: 'VT323'; font-size: 2rem; padding: 20px 50px; cursor: pointer;
            text-shadow: 0 0 10px var(--blood); box-shadow: 0 0 20px var(--dark-blood);
            transition: 0.2s; animation: pulse 2s infinite;
        }
        .btn-blood:hover { background: var(--blood); color: #000; }

        /* --- UI JEU --- */
        #ui-layer { display: none; width: 100%; max-width: 500px; flex-direction: column; align-items: center; z-index: 10; padding: 10px; }
        
        #demon-box {
            min-height: 80px; width: 100%; text-align: center; border: 1px solid #333;
            background: #050505; color: var(--blood); padding: 10px; margin-bottom: 20px;
            font-size: 1.4rem; display: flex; align-items: center; justify-content: center;
            text-shadow: 0 0 5px var(--blood); box-shadow: inset 0 0 30px #000;
        }

        #stress-bar-container { width: 100%; height: 10px; background: #222; margin-bottom: 20px; border: 1px solid #444; }
        #stress-bar { width: 0%; height: 100%; background: var(--blood); box-shadow: 0 0 15px var(--blood); transition: width 0.2s; }

        #grid {
            display: grid; grid-template-columns: repeat(9, 1fr); gap: 2px;
            background: #444; border: 4px solid #222; width: 100%; aspect-ratio: 1; margin-bottom: 20px;
        }
        .cell {
            background: #000; display: flex; align-items: center; justify-content: center;
            font-size: 1.8rem; color: #aaa; cursor: pointer; transition: 0.1s;
        }
        .cell.fixed { color: #444; background: #080808; pointer-events: none; }
        .cell.selected { background: #200; box-shadow: inset 0 0 20px var(--blood); color: #fff; }
        .cell.error { background: var(--blood); color: #000; animation: shake 0.4s; }
        
        #keypad { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; width: 100%; }
        .key {
            background: #111; border: 1px solid #444; color: #fff; height: 50px;
            display: flex; align-items: center; justify-content: center; font-size: 1.5rem; cursor: pointer;
        }
        .key:active { background: var(--blood); }

        /* --- CINEMATICS --- */
        #cinematic-overlay {
            display: none; position: fixed; inset: 0; background: #000; z-index: 4000;
            flex-direction: column; align-items: center; justify-content: center; padding: 40px;
            pointer-events: none;
        }
        #cinematic-text {
            color: var(--blood); font-size: 1.5rem; text-align: left; white-space: pre-wrap;
            line-height: 1.5; text-shadow: 0 0 4px var(--blood); border-left: 2px solid var(--blood);
            padding-left: 20px; max-width: 800px;
        }

        @keyframes pulse { 0% {opacity:1} 50% {opacity:0.5} 100% {opacity:1} }
        @keyframes shake { 0% {transform:translate(0,0)} 25% {transform:translate(-5px, 5px)} 75% {transform:translate(5px, -5px)} 100% {transform:translate(0,0)} }
        
        .screen-shake { animation: shake 0.5s infinite; }
        .red-flash { animation: flashRed 0.2s; }
        @keyframes flashRed { 0% {background:rgba(255,0,0,0.5)} 100% {background:transparent} }

    </style>
</head>
<body>

<div class="scanline"></div>

<div id="start-overlay">
    <h1 class="glitch" data-text="SUDOKU: PURGATOIRE" style="margin-bottom: 50px; font-size: 4rem;">SUDOKU: PURGATOIRE</h1>
    <button class="btn-blood" onclick="initSystem()">LANCER LE RITUEL</button>
    <p style="margin-top: 20px; color: #444; font-size: 0.9rem;">CASQUE REQUIS. LE VOLUME DOIT ÊTRE ÉLEVÉ.</p>
</div>

<div id="cinematic-overlay">
    <div id="cinematic-text"></div>
    <button id="retry-btn" class="btn-blood" style="display:none; margin-top:30px;" onclick="location.reload()">OFFRIR UNE AUTRE ÂME</button>
</div>

<div id="ui-layer">
    <div style="width:100%; display:flex; justify-content:space-between; margin-bottom:5px; color:#555;">
        <span>NIVEAU: <span id="lvl" style="color:#fff">1</span></span>
        <span>VICTIME: <span id="player-name">...</span></span>
    </div>
    <div id="stress-bar-container"><div id="stress-bar"></div></div>
    
    <div id="demon-box">INITIALISATION DU SUPPLICE...</div>

    <div id="grid"></div>

    <div id="keypad">
        <div class="key" onclick="input(1)">1</div>
        <div class="key" onclick="input(2)">2</div>
        <div class="key" onclick="input(3)">3</div>
        <div class="key" onclick="input(4)">4</div>
        <div class="key" onclick="input(5)">5</div>
        <div class="key" onclick="input(6)">6</div>
        <div class="key" onclick="input(7)">7</div>
        <div class="key" onclick="input(8)">8</div>
        <div class="key" onclick="input(9)">9</div>
        <div class="key" onclick="input('X')" style="color:red; border:1px solid red">X</div>
    </div>
</div>

<script>
    // --- VARIABLES GLOBALES ---
    const GAME = {
        level: 1,
        stress: 0,
        active: false,
        grid: [],
        sol: [],
        sel: null,
        name: "ANONYME",
        timer: 0
    };

    // --- MOTEUR AUDIO HORRIFIQUE ---
    const AUDIO = {
        ctx: null,
        ambience: null,
        voiceDrone: null,

        init: function() {
            const AC = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AC();
            
            // Bruit de fond industriel/oppressant
            this.createAmbience();
        },

        createAmbience: function() {
            // Création d'un drone "Brown Noise" simulé pour le fond
            const bufferSize = 2 * this.ctx.sampleRate;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                data[i] = (0 + (0.1 * white)) * 0.5; // Simple noise
            }

            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            noise.loop = true;
            
            // Filtre passe-bas pour ne garder que les graves (grondement)
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 150;
            
            const gain = this.ctx.createGain();
            gain.gain.value = 0.5;

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(this.ctx.destination);
            noise.start();
            this.ambience = { node: filter, gain: gain };
        },

        stressUp: function(val) {
            // Plus le stress monte, plus le son sature et monte en fréquence
            if(this.ambience) {
                this.ambience.node.frequency.setTargetAtTime(150 + (val * 3), this.ctx.currentTime, 1);
                this.ambience.gain.gain.setTargetAtTime(0.5 + (val/150), this.ctx.currentTime, 1);
            }
        },

        // LA VOIX DU DEMON : TTS + Oscillateur Basse Fréquence
        speak: function(text) {
            // 1. Synthèse vocale navigateur (réglée très bas)
            window.speechSynthesis.cancel();
            const utt = new SpeechSynthesisUtterance(text);
            utt.lang = 'fr-FR'; // Force French
            utt.pitch = 0.1; // Le plus grave possible
            utt.rate = 0.8;  // Lent
            utt.volume = 1;
            
            // Tenter de trouver une voix Google FR
            const voices = window.speechSynthesis.getVoices();
            const frVoice = voices.find(v => v.name.includes('Google') && v.lang.includes('fr'));
            if(frVoice) utt.voice = frVoice;

            // 2. Grondement synchronisé (L'astuce pour l'immersion)
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.type = 'sawtooth'; // Son agressif
            osc.frequency.setValueAtTime(45, this.ctx.currentTime); // Sub-bass
            // Modulation de fréquence pour effet "voix instable"
            osc.frequency.linearRampToValueAtTime(40, this.ctx.currentTime + text.length * 0.1);
            
            gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + (text.length * 0.08));

            osc.connect(gain);
            gain.connect(this.ctx.destination);
            
            osc.start();
            osc.stop(this.ctx.currentTime + (text.length * 0.1)); // Stop quand le texte finit environ
            
            window.speechSynthesis.speak(utt);
        },

        sfx: function(type) {
            const t = this.ctx.currentTime;
            const o = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            o.connect(g); g.connect(this.ctx.destination);

            if(type === 'hit') { // Bruit de coup/glitch
                o.type = 'square';
                o.frequency.setValueAtTime(100, t);
                o.frequency.exponentialRampToValueAtTime(0.01, t + 0.1);
                g.gain.setValueAtTime(0.5, t);
                g.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                o.start(); o.stop(t+0.1);
            } else if (type === 'type') { // Bruit clavier
                o.type = 'triangle';
                o.frequency.setValueAtTime(800, t);
                g.gain.setValueAtTime(0.05, t);
                g.gain.linearRampToValueAtTime(0, t+0.03);
                o.start(); o.stop(t+0.03);
            }
        }
    };

    // --- SCENARIOS GORE ---
    const DEATHS = [
        "SCÉNARIO #402\nSujet immobilisé.\nInjection d'acide chlorhydrique dans les veines.\nLe sujet hurle alors que ses organes fondent de l'intérieur.\nDécès confirmé par liquéfaction totale.",
        
        "SCÉNARIO #891\nLa mâchoire du sujet est forcée ouverte.\nInsertion d'un nid de scolopendres dans l'œsophage.\nLes insectes dévorent la trachée.\nAsphyxie lente et douloureuse.",
        
        "SCÉNARIO #101\nDécapitation manuelle.\nJ'arrache la tête en tirant sur la colonne vertébrale.\nLe corps convulse encore pendant 12 secondes.\nJe garde le crâne en trophée.",
        
        "SCÉNARIO #666\nLe sol s'ouvre.\nDes crochets rouillés transpercent la peau du dos.\nLe sujet est hissé au plafond, écorché vif sous son propre poids.\nIl pleut du sang.",
        
        "SCÉNARIO #012\nJ'enfonce mes pouces dans tes orbites.\nJe sens la gélatine de tes yeux céder.\nJe touche ton cerveau.\nTu ne vois plus que le néant rouge."
    ];

    // --- SYSTEME PRINCIPAL ---
    function initSystem() {
        document.getElementById('start-overlay').style.display = 'none';
        AUDIO.init();
        
        // Input Nom "In-Game" façon terminal
        playCinematic("IDENTIFICATION REQUISE...\n\nEntrez votre nom pour l'épitaphe :", true);
    }

    // Affiche du texte lettre par lettre (effet dactylo)
    async function typeWriter(text, elementId, speed = 30) {
        const el = document.getElementById(elementId);
        el.innerHTML = "";
        for (let i = 0; i < text.length; i++) {
            el.innerHTML += text.charAt(i);
            AUDIO.sfx('type');
            if(text.charAt(i) === '\n') await new Promise(r => setTimeout(r, 400));
            await new Promise(r => setTimeout(r, speed));
        }
    }

    function playCinematic(text, askName = false) {
        const ov = document.getElementById('cinematic-overlay');
        const txt = document.getElementById('cinematic-text');
        const retry = document.getElementById('retry-btn');
        
        ov.style.display = 'flex';
        ov.style.pointerEvents = 'auto';
        retry.style.display = 'none';
        
        typeWriter(text, 'cinematic-text', 40).then(() => {
            if(askName) {
                // Création dynamique de l'input
                let inp = document.createElement('input');
                inp.type = 'text';
                inp.style.background = 'transparent';
                inp.style.border = 'none';
                inp.style.borderBottom = '2px solid red';
                inp.style.color = 'red';
                inp.style.fontFamily = 'inherit';
                inp.style.fontSize = '2rem';
                inp.style.marginTop = '20px';
                inp.style.outline = 'none';
                inp.focus();
                
                txt.appendChild(document.createElement('br'));
                txt.appendChild(inp);
                inp.focus();
                
                inp.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        GAME.name = inp.value.toUpperCase() || "VIANDE";
                        ov.style.display = 'none';
                        document.getElementById('ui-layer').style.display = 'flex';
                        document.getElementById('player-name').innerText = GAME.name;
                        startGame();
                    }
                });
            } else {
                retry.style.display = 'block';
            }
        });
    }

    function startGame() {
        GAME.active = true;
        GAME.level = 1;
        AUDIO.speak("Bienvenue en enfer, " + GAME.name);
        startLevel();
        gameLoop();
    }

    function startLevel() {
        // RESET STRESS
        GAME.stress = 0;
        AUDIO.stressUp(0);
        document.getElementById('stress-bar').style.width = '0%';
        
        // GENERATION SUDOKU
        let holes = 10 + (GAME.level * 5); // Dur dès le début
        if(holes > 50) holes = 50;
        
        let board = Array(81).fill(0);
        fillSudoku(board);
        GAME.sol = [...board];
        
        for(let i=0; i<holes; i++) board[Math.floor(Math.random()*81)] = 0;
        GAME.grid = board;
        
        // RENDER
        const g = document.getElementById('grid');
        g.innerHTML = '';
        GAME.grid.forEach((v, i) => {
            let c = document.createElement('div');
            c.className = v ? 'cell fixed' : 'cell';
            if(v) c.innerText = v;
            else c.onclick = () => selectCell(c, i);
            g.appendChild(c);
        });
        
        document.getElementById('lvl').innerText = GAME.level;
    }

    function selectCell(el, idx) {
        if(!GAME.active) return;
        document.querySelectorAll('.selected').forEach(e=>e.classList.remove('selected'));
        el.classList.add('selected');
        GAME.sel = idx;
    }

    function input(n) {
        if(GAME.sel === null || !GAME.active) return;
        
        const cell = document.getElementById('grid').children[GAME.sel];
        
        if(n === 'X') { cell.innerText = ''; return; }
        
        if(n == GAME.sol[GAME.sel]) {
            // BON
            cell.innerText = n;
            cell.className = 'cell fixed';
            cell.style.color = '#0f0'; // Petit vert glitchy
            GAME.grid[GAME.sel] = n;
            
            // Gain de sursis
            GAME.stress = Math.max(0, GAME.stress - 10);
            
            // Check win
            if(!GAME.grid.includes(0)) {
                GAME.level++;
                AUDIO.speak("Tu retardes l'inévitable.");
                setTimeout(startLevel, 1000);
            }
        } else {
            // ERREUR
            AUDIO.sfx('hit');
            document.body.classList.add('red-flash');
            setTimeout(()=>document.body.classList.remove('red-flash'), 200);
            
            // Punition Violente
            GAME.stress += 25;
            AUDIO.speak("NON !");
            
            let phrases = ["Je vais te briser.", "Concentre-toi, ver de terre.", "Tu sens l'odeur du sang ?", "Encore une erreur..."];
            document.getElementById('demon-box').innerText = phrases[Math.floor(Math.random()*phrases.length)];
        }
    }

    function gameLoop() {
        if(!GAME.active) return;
        
        // Stress monte tout seul et VITE
        let speed = 0.04 + (GAME.level * 0.02);
        GAME.stress += speed;
        
        document.getElementById('stress-bar').style.width = Math.min(100, GAME.stress) + '%';
        AUDIO.stressUp(GAME.stress);
        
        // Effet de tremblement si stress haut
        if(GAME.stress > 80) document.body.style.transform = `translate(${Math.random()*2}px, ${Math.random()*2}px)`;
        else document.body.style.transform = 'none';

        if(GAME.stress >= 100) {
            triggerDeath();
        } else {
            requestAnimationFrame(gameLoop);
        }
    }

    function triggerDeath() {
        GAME.active = false;
        document.body.classList.add('screen-shake');
        AUDIO.sfx('hit');
        
        // Délai dramatique
        setTimeout(() => {
            document.body.classList.remove('screen-shake');
            document.getElementById('ui-layer').style.display = 'none';
            
            // Choix du scénario
            let scenar = DEATHS[Math.floor(Math.random() * DEATHS.length)];
            
            // Voix finale
            AUDIO.speak("C'est fini pour toi.");
            
            // Lancer cinématique
            playCinematic(scenar);
            
        }, 1000);
    }

    // --- SUDOKU UTIL (Minimal) ---
    function fillSudoku(b) {
        const find = (b) => {
            for(let i=0; i<81; i++) {
                if(b[i]==0) {
                    let nums = [1,2,3,4,5,6,7,8,9].sort(()=>Math.random()-.5);
                    for(let n of nums) {
                        if(valid(b,i,n)) {
                            b[i]=n;
                            if(find(b)) return true;
                            b[i]=0;
                        }
                    }
                    return false;
                }
            }
            return true;
        };
        find(b);
    }
    function valid(b,i,n) {
        let r=Math.floor(i/9), c=i%9;
        for(let k=0; k<9; k++) {
            if(b[r*9+k]==n || b[k*9+c]==n) return false;
            let br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
            if(b[(br+Math.floor(k/3))*9+(bc+k%3)]==n) return false;
        }
        return true;
    }

</script>
</body>
</html>
